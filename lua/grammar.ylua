%require "common.utils"

%file "lua/parser"

%quote '(' LPAREN
%quote ',' COMMA
%quote ':' COLON
%quote '[' LBRACK
%quote ']' RBRACK
%quote '.' PERIOD
%quote '~=' NOTEQ
%quote '==' EQEQ
%quote '>=' GE
%quote '>' GT
%quote '<=' LE
%quote '<' LT
%quote '..' CONCAT
%quote '%' MOD
%quote '^' POW
%quote '/' DIV
%quote '*' MUL
%quote '-' MIN
%quote '+' PLUS
%quote '=' EQ
%quote '#' HASH
%quote ')' RPAREN
%quote ';' SEMICOLON
%quote '...' DOTS
%quote '{' LBRACE
%quote '}' RBRACE
%quote '::' QUAD
%quote 'function' FUNCTION
%quote 'true' TRUE
%quote 'false' FALSE
%quote 'nil' NIL
%quote 'or' OR
%quote 'and' AND
%quote 'return' RETURN
%quote 'local' LOCAL
%quote 'for' FOR
%quote 'in' IN
%quote 'do' DO
%quote 'end' END
%quote 'if' IF
%quote 'not' NOT
%quote 'then' THEN
%quote 'else' ELSE
%quote 'elseif' ELSEIF
%quote 'repeat' REPEAT
%quote 'until' UNTIL
%quote 'while' WHILE
%quote 'goto' GOTO
%quote 'break' BREAK

// Character classes of tokens
%production Name "class of valid identifiers"
%production String "class of valid strings"
%production Number "class of valid numbers"

%production FUNCTION
%production EQ
%production COMMA
%production QUAD
%production PERIOD
%production LPAREN
%production RPAREN
%production END
%production SEMICOLON
%production LBRACE
%production RBRACE
%production OR
%production AND
%production NOTEQ
%production EQEQ
%production GE
%production GT
%production LE
%production LT
%production CONCAT
%production MOD
%production POW
%production DIV
%production MUL
%production MIN
%production PLUS
%production LBRACK
%production RBRACK
%production LOCAL
%production FOR
%production IF
%production THEN
%production REPEAT
%production UNTIL
%production WHILE
%production DO
%production GOTO
%production BREAK
%production IN
%production RETURN
%production DOTS
%production TRUE
%production FALSE
%production NIL
%production ELSE
%production ELSEIF
%production HASH
%production NOT
%production COLON

// Let's create a set of trees where the children are recorded as integer indices
// and also as named fields
%code {:

local ast = {}
function ast:__newindex(key, val)
  print(key, val)
  if type(key) ~= 'string' then
    rawset(self, key, val)
  end
  assert(not self[key], 'Fields passed to a node should be initialized only once.')
  rawset(self, key, val)
  -- other stuff
  if val.kind then
    table.insert(self, val)
    assert(not val.parent, 'Fields passed to a node should be unowned.')
    rawset(val, 'parent', self)
  end
end

function ast:set(key, val)
  if not key or not val then return self end
  assert(val.kind, 'Set should only be called on child trees.')
  self[key] = val
  return self
end

function ast:list(...)
  list = {...}
  for child in utils.loop(list) do
    assert(child.kind, 'List should only be called on child trees.')
    table.insert(self, child)
    assert(not child.parent, 'Children passed to list(...) should be unowned.')
    rawset(child, 'parent', self)
  end
  return self
end

local function node(kind)
  return setmetatable({kind = kind}, {__index = ast, __newindex = ast.__newindex})
end

local function from(token)
  print(token)
  local leaf = node 'leaf'
  leaf.value = token
  return leaf
end
:}

// A lua file is just a block
root := $block [: _1 :]

block := $stat* $retstat? {: function(stats, ret)
  local tree = node 'block'
  tree:list(unpack(stats))
  
  return tree:set('ret', (#ret ~= 0 and ret[1]) or nil) 
end
:}

stat := ';' | 
  $assignment_or_call |
  $label | 
  'break' | 
  'goto' Name | 
  'do' $block 'end' | 
  'while' $exp 'do' $block 'end' | 
  'repeat' $block 'until' $exp | 
  'if' $exp 'then' $block ('elseif' $exp 'then' $block)* ('else' $block)? 'end' | 
  'for' (
      <forcounter> Name '=' $exp ',' $exp (',' $exp)? 'do' $block 'end' | 
      <foreach> $namelist 'in' $explist 'do' $block 'end') | 
  'function' $funcname $funcbody | 
  'local' ('function' Name $funcbody | $namelist ('=' $explist)?)

%resolve stat'group#2 Name {: function(self, tokens)
  if tokens[2] == 'EQ' then
    return self:go 'forcounter'
  else
    return self:go 'foreach'
  end
end :}

// just return the explist
retstat := 'return' $explist? ';'? [: #_2 == 0 and {} or _2[1] :]

label := '::' Name '::' [: node('label'):set('name', from(_2)) :]

funcname := Name ('.' Name [: from(_2) :])* (':' Name [: from(_2) :])? {:
  function(name, names, colon)
    colon = colon[1]
    table.insert(names, 1, from(name))
    if colon then
      table.insert(names, colon)
      names.colon = colon
    end
  end
:}

namelist := Name (',' Name [: from(_2) :])* {:
  function(name, names)
    table.insert(names, 1, from(name))
    return names
  end
:}

explist := $exp (',' $exp [: _2 :])* {:
  function(exp, explist)
    local tree = node 'explist'
    tree:list(exp)
    tree:list(unpack(explist))
    return tree
  end
:}

%code {:
-- this will either reduce to an index, a call, a name, or a grouped expression
local function handle_primary_suffix(primary, suffixlist)
  error 'unimplemented'
end
:}

// there's a conflict on $binop between reducing the maybe? rule or going into the binop of the exp.
// luckily for us, since not binds are not as tight as the binary operators, we'd always be reducing the rule
exp := ('nil' {: from :} 
      | 'false' {: from :} 
      | 'true' {: from :} 
      | Number {: from :} 
      | String {: from :} 
      | '...' {: from :} 
      | $functiondef [: _1 :] 
      | $primaryexp $suffix* {: handle_primary_suffix :} 
      | $tableconstructor [: _1 :] 
      | $unop $exp [: node('unop'):set('operator', _):set('operand', _2) :]
        ) ($binop $exp [: {_1, _2} :])? // TODO: resolve conflict @ suffix*
          {:
            function(left, binops_opt)
              local binop, right = unpack(binops_opt[1] or {})
              if binop then
                local tree = node 'binop'
                tree.left = left
                tree.right = right
                return tree
              end
              return left
            end
          :}

%code {: local function goto_present(self) return self:go '#present' end :}
%resolve exp'maybe#1 '^' {: goto_present :}
%resolve exp'maybe#1 '==' {: goto_present :}
%resolve exp'maybe#1 '>=' {: goto_present :}
%resolve exp'maybe#1 '~=' {: goto_present :}
%resolve exp'maybe#1 '<=' {: goto_present :}
%resolve exp'maybe#1 '*' {: goto_present :}
%resolve exp'maybe#1 '>' {: goto_present :}
%resolve exp'maybe#1 '..' {: goto_present :}
%resolve exp'maybe#1 'and' {: goto_present :}
%resolve exp'maybe#1 'or' {: goto_present :}
%resolve exp'maybe#1 '/' {: goto_present :}
%resolve exp'maybe#1 '-' {: goto_present :}
%resolve exp'maybe#1 '+' {: goto_present :}
%resolve exp'maybe#1 '<' {: goto_present :}
%resolve exp'maybe#1 '%' {: goto_present :}

%code {: local function goto_list(self) return self:go '#list' end :}
%resolve exp'group#1'star#1 '[' {: goto_list :}
%resolve exp'group#1'star#1 String {: goto_list :}
%resolve exp'group#1'star#1 '{' {: goto_list :}
%resolve exp'group#1'star#1 '(' {: goto_list :}

%code {:
  local function suffix_dot(_, name)
    return {
      index = from(name),
      args = nil,
    }
  end
  local function suffix_bracket(_, exp)
    return {
      index = exp,
      args = nil,
    }
  end
  local function suffix_colon(_, name, args)
    return {
      index = from(name),
      args = args,
    }
  end
  local function suffix_args(args)
    return {
      index = nil,
      args = args,
    }
  end
:}

suffix := '.' Name {: suffix_dot :} | '[' $exp ']' {: suffix_bracket :} | ':' Name $args {: suffix_colon :} | $args {: suffix_args :}
primaryexp := Name [: from(_1) :] | '(' $exp ')' [: _2 :]

// %eps is func, the other 2 are assignments
// let's rule out the possibility of f() = x
assignment_or_call := $primaryexp (
                          '.' Name {: suffix_dot :}
                        | '[' $exp ']' {: suffix_bracket :}
                        | ':' Name $args {: suffix_colon :}
                        | <call> $args {: suffix_args :})* $assignment?
                      {:
                        function(left, suffixes, assignment_opt)
                          local assignment = #assignment_opt == 0 and {} or assignment_opt[1]
                          -- let's reduce to call or assignment
                          if (#suffixes == 0 or not suffixes[#suffixes].arg) and #assignment == 0 then
                            error('Parser error: you can only specify a call or an assignment here')
                          end
                          if #suffixes ~= 0 and #assignment ~= 0 and suffixes[#suffixes].arg then
                            error 'Parser error: you cannot assign to a call'
                          end
                          
                          if #assignment ~= 0 then
                            -- assignment case
                            -- assignment is a list of subsequent assignments
                            local lvals, rvals = unpack(assignment)
                            local tree = node 'assignments'
                            tree.left = lvals
                            tree.right = rvals
                          else
                            -- call case
                            return handle_primary_suffix(left, suffixes)
                          end
                        end
                      :}
assignment := ',' $primaryexp $suffix* $assignment 
              {: 
                function(_1, _2, _3) 
                  local left, right = unpack(_3)
                  left:list(handle_primary_suffix(_1, _2)); 
                  return {left, right}
                end :}
            | '=' $explist [: {node 'lvalue', _2} :]

    // Hack to get around the fact that one branch of this is always
    // "dead" states that would get killed later on anyways
    %resolve assignment_or_call'star#1 '(' {: function(self, tokens)
      -- always reduce to call
      return self:go 'call'
    end :}

    // prefixexp := $var | $functioncall | '(' $exp ')'
    // functioncall := $prefixexp ($args | ':' Name $args)
    // varlist := $var (',' $var)*
    // var := Name | $prefixexp ('[' $exp ']' | '.' Name)

args := '(' $explist? ')' [: (#_2 == 0 and node 'args') or node('args'):list(unpack(_2[1])) :] 
      | $tableconstructor [: node('args'):list(_1) :]
      | String [: node('args'):list(from(_1)) :]

functiondef := 'function' $funcbody [: node('function'):set('parameters', _2[1]):set('body', _2[2]) :]

funcbody := '(' $parlist? ')' $block 'end'
          {: 
            function(_, parameters_opt, _, block)
              local parameters = (#parameters_opt == 0 and {}) or parameters_opt[1]
              return {parameters, block}
            end 
          :}

    // resolve conflict for parlist := (Name ',')+ Name; based on tokens[2] being , or not
    %code {:
      local function parlist_namelist(namelist, trail)
        local parameters = node 'parameters'
        for name in utils.loop(parameters) do
          parameters:list(from(name))
        end
        if trail[1] == 'DOTS' then
          parameters.vararg = from(trail)
        else
          parameters:list(from(trail))
        end
      end
    :}

parlist := (<namelist> Name ',' [: _1 :])+ (Name [: _1 :] | '...' [: _1 :]) 
            {: parlist_namelist :}
         | '...' 
            [: node('parameters'):list(from(_1)) :]

        %resolve parlist'star#1 Name {: function(self, tokens)
          if tokens[2] == 'COMMA' then
            return self:go 'namelist'
          else
            return self:go ''
          end
        end :}

// TODO: ensure that only the last $field has an optional $fieldsep
tableconstructor := '{' $field* '}' 
    [: node('table'):list(unpack(_2)) :]

// Conflict resolvers, since the approximation of Lua we're parsing is not LL(1) (but is LL(2))
field := '[' $exp ']' '=' $exp $fieldsep? [: node('element'):set('index', _2):set('value', _5) :]
       | <assign> Name '=' $exp $fieldsep? [: node('element'):set('index', from(_1)):set('value', _3) :]
       | <exp> $exp $fieldsep? [: node('element'):set('value', _1) :]
%resolve field Name {: function(self, tokens)
  if tokens[2] == 'EQ' then
    return self:go 'assign'
  else
    return self:go 'exp'
  end
end :}

fieldsep [: {} :] := ',' | ';'

binop [: from(_1) :] := '+' | '-' | '*' | '/' | '^' | '%' | '..' | 
  '<' | '<=' | '>' | '>=' | '==' | '~=' | 
  'and' | 'or'

unop [: from(_1) :] := '-' | 'not' | '#'