%require "common.utils"
%require "lua.tokenizer"

%file "lua/parser"

%quote '(' LPAREN
%quote ',' COMMA
%quote ':' COLON
%quote '[' LBRACK
%quote ']' RBRACK
%quote '.' PERIOD
%quote '~=' NOTEQ
%quote '==' EQEQ
%quote '>=' GE
%quote '>' GT
%quote '<=' LE
%quote '<' LT
%quote '..' CONCAT
%quote '%' MOD
%quote '^' POW
%quote '/' DIV
%quote '*' MUL
%quote '-' MIN
%quote '+' PLUS
%quote '=' EQ
%quote '#' HASH
%quote ')' RPAREN
%quote ';' SEMICOLON
%quote '...' DOTS
%quote '{' LBRACE
%quote '}' RBRACE
%quote '::' QUAD
%quote 'function' FUNCTION
%quote 'true' TRUE
%quote 'false' FALSE
%quote 'nil' NIL
%quote 'or' OR
%quote 'and' AND
%quote 'return' RETURN
%quote 'local' LOCAL
%quote 'for' FOR
%quote 'in' IN
%quote 'do' DO
%quote 'end' END
%quote 'if' IF
%quote 'not' NOT
%quote 'then' THEN
%quote 'else' ELSE
%quote 'elseif' ELSEIF
%quote 'repeat' REPEAT
%quote 'until' UNTIL
%quote 'while' WHILE
%quote 'goto' GOTO
%quote 'break' BREAK

// Character classes of tokens
%production Name "class of valid identifiers"
%production String "class of valid strings"
%production Number "class of valid numbers"

%production FUNCTION
%production EQ
%production COMMA
%production QUAD
%production PERIOD
%production LPAREN
%production RPAREN
%production END
%production SEMICOLON
%production LBRACE
%production RBRACE
%production OR
%production AND
%production NOTEQ
%production EQEQ
%production GE
%production GT
%production LE
%production LT
%production CONCAT
%production MOD
%production POW
%production DIV
%production MUL
%production MIN
%production PLUS
%production LBRACK
%production RBRACK
%production LOCAL
%production FOR
%production IF
%production THEN
%production REPEAT
%production UNTIL
%production WHILE
%production DO
%production GOTO
%production BREAK
%production IN
%production RETURN
%production DOTS
%production TRUE
%production FALSE
%production NIL
%production ELSE
%production ELSEIF
%production HASH
%production NOT
%production COLON

%prologue {:
  function(stream)
    local tokens = {}
    for token in tokenizer(stream) do
      table.insert(tokens, token)
    end
    return tokens
  end
:}

// Let's create a set of trees where the children are recorded as integer indices
// and also as named fields
%code {:

local ast = {}
function ast:__newindex(key, val)
  if type(key) ~= 'string' then
    return rawset(self, key, val)
  end
  assert(not self[key], 'Fields passed to a node should be initialized only once.')
  rawset(self, key, val)
  -- other stuff
  if val.kind then
    table.insert(self, val)
    assert(not val.parent, 'Fields passed to a node should be unowned.')
    rawset(val, 'parent', self)
  end
end

function ast:set(key, val)
  if not key or not val then return self end
  assert(val.kind, 'Set should only be called on child trees.')
  self[key] = val
  return self
end

function ast:list(...)
  local list = {...}
  for child in utils.loop(list) do
    if not child.kind then
      print(debug.traceback())
    end
    assert(child.kind, 'List should only be called on child trees.')
    table.insert(self, child)
    assert(not child.parent, 'Children passed to list(...) should be unowned.')
    rawset(child, 'parent', self)
  end
  return self
end

function ast:children()
  return utils.loop(self)
end

local function node(kind)
  return setmetatable({kind = kind}, {__index = ast, __newindex = ast.__newindex})
end

local function from(token, kind)
  if not kind then kind = 'leaf' end
  if tostring(token) == 'Name' then
    local leaf = node 'name'
    leaf.token = token
    leaf.value = token[2]
    return leaf
  end
  local leaf = node(kind)
  leaf.token = token
  leaf.value = token[2]
  return leaf
end
:}


// =======================================================================================
// ===                                 GRAMMAR RULES                                   ===
// =======================================================================================


// A lua file is just a block
root := $block [: _1 :]

block := $stat* $retstat? {: function(stats, ret)
  local tree = node 'block'
  tree:list(unpack(stats))
  return tree:set('ret', (#ret ~= 0 and ret[1]) or nil) 
end
:}

stat := ';' [: node 'empty' :]
      | $assignment_or_call [: _1 :]
      | $label [: _1 :]
      | 'break' [: node 'break' :]
      | 'goto' Name [: node('goto'):set('label', from(_2)) :]
      | 'do' $block 'end' [: _2 :]
      | 'while' $exp 'do' $block 'end' [: node('while'):set('cond', _2):set('block', _4) :]
      | 'repeat' $block 'until' $exp [: node('repeat'):set('cond', _4):set('block', _2) :]
      | 'if' $exp 'then' $block 
          ('elseif' $exp 'then' $block [: node('elseif'):set('cond', _2):set('block', _4) :])* 
          ('else' $block [: node('else'):set('block', _2) :])? 'end' 
              [: node('if'):set('cond', _2):set('block', _4):list(unpack(_5)):set('else', _6[1]) :]
      | 'for' (
          <forcounter> Name '=' $exp ',' $exp (',' $exp [: _2 :])?  'do' $block 'end'
            [: node('fori'):set('id', from(_1)):set('start', _3):set('finish', _5):set('step', _6[1]):set('block', _8) :]
        | <foreach> $namelist 'in' $explist 'do' $block 'end'
            [: node('foreach'):set('names', _1):set('iterator', _3):set('block', _5) :]) 
              /* Whole action */ [: _2 :]
      | 'function' $funcname $funcbody 
          [: node('functiondef'):set('funcname', _2):set('function', node('function'):set('parameters', _3[1]):set('body', _3[2])) :]
      | 'local' ('function' Name $funcbody 
            [: node('localfunctiondef'):set('name', from(_2)):set('function', node('function'):set('parameters', _3[1]):set('body', _3[2])) :]
        | $namelist ('=' $explist [: _2 :])?
            [: node('localassign'):set('left', _1):set('right', _2[1]) :]
            ) [: _2 :]

%resolve stat'group#2 Name {: function(self, tokens)
  if tostring(tokens[2]) == 'EQ' then
    return self:go 'forcounter'
  else
    return self:go 'foreach'
  end
end :}

// just return the explist
retstat := 'return' $explist? ';'? [: #_2 == 0 and node 'return' or node('return'):set('explist', _2[1]) :]

label := '::' Name '::' [: node('label'):set('name', from(_2)) :]

funcname := Name ('.' Name [: from(_2) :])* (':' Name [: from(_2) :])? {:
  function(name, names, colon)
    local tree = node 'funcnames'
    colon = colon[1]
    tree:list(from(name))
    tree:list(unpack(names))
    if colon then
      tree.colon = colon
    end
    return tree
  end
:}

namelist := Name (',' Name [: from(_2) :])* {:
  function(name, names)
    local tree = node 'names'
    tree:list(from(name))
    tree:list(unpack(names))
    return tree
  end
:}

explist := $exp (',' $exp [: _2 :])* {:
  function(exp, explist)
    local tree = node 'explist'
    tree:list(exp)
    tree:list(unpack(explist))
    return tree
  end
:}

%code {:
-- this will either reduce to an index, a call, a name, or a grouped expression
-- // Shape of a suffix: {index = shape(from(name)), args = shape(args)}
-- suffix := '.' Name {\: suffix_dot :\} // field
--         | '[' $exp ']' {\: suffix_bracket :\} // field
--         | ':' Name $args {\: suffix_colon :\} // arg
--         | $args {\: suffix_args :\} // arg
-- primaryexp := Name [: from(_1) :] 
--         | '(' $exp ')' [: _2 :]
-- primary_suffix := $primaryexp $suffix*
-- Plan: recurse on the structural inductive properties of a list
local function handle_primary_suffix(left, suffixlist)
  if #suffixlist == 0 then
    return left
  end
  -- pop the first element out of suffixlist
  local suffix = suffixlist[1]
  local rest = utils.sublist(suffixlist, 2)
  if suffix.index and not suffix.args then
    return handle_primary_suffix(
        node('index'):set('left', left):set('right', suffix.index), 
        rest)
  elseif suffix.args and not suffix.index then
    return handle_primary_suffix(
        node('call'):set('target', left):set('args', suffix.args), 
        rest)
  elseif suffix.args and suffix.index then
    local index = node('index'):set('left', left):set('right', suffix.index)
    return handle_primary_suffix(
        node('selfcall'):set('target', index):set('args', suffix.args), 
        rest)
  end
  error 'unimplemented'
end
:}

// there's a conflict on $binop between reducing the maybe? rule or going into the binop of the exp.
// luckily for us, since not binds are not as tight as the binary operators, we'd always be reducing the rule
exp := ('nil' [: node 'nil' :]
      | 'false' [: node 'false' :]
      | 'true' [: node 'true' :]
      | Number [: from(_1, 'number') :]
      | String [: from(_1, 'string') :]
      | '...' {: node 'vararg' :}
      | $functiondef [: _1 :] 
      | $primaryexp $suffix* {: handle_primary_suffix :} 
      | $tableconstructor [: _1 :] 
      | $unop $exp [: node('unop'):set('operator', _1):set('operand', _2) :]
        ) ($binop $exp [: {_1, _2} :])? // TODO: resolve conflict @ suffix*
          {:
            function(left, binops_opt)
              local binop, right = unpack(binops_opt[1] or {})
              if binop then
                local tree = node 'binop'
                tree.left = left
                tree.right = right
                return tree
              end
              return left
            end
          :}

%code {: local function goto_present(self) return self:go '#present' end :}
%resolve exp'maybe#1 '^' {: goto_present :}
%resolve exp'maybe#1 '==' {: goto_present :}
%resolve exp'maybe#1 '>=' {: goto_present :}
%resolve exp'maybe#1 '~=' {: goto_present :}
%resolve exp'maybe#1 '<=' {: goto_present :}
%resolve exp'maybe#1 '*' {: goto_present :}
%resolve exp'maybe#1 '>' {: goto_present :}
%resolve exp'maybe#1 '..' {: goto_present :}
%resolve exp'maybe#1 'and' {: goto_present :}
%resolve exp'maybe#1 'or' {: goto_present :}
%resolve exp'maybe#1 '/' {: goto_present :}
%resolve exp'maybe#1 '-' {: goto_present :}
%resolve exp'maybe#1 '+' {: goto_present :}
%resolve exp'maybe#1 '<' {: goto_present :}
%resolve exp'maybe#1 '%' {: goto_present :}

%code {: local function goto_list(self) return self:go '#list' end :}
%resolve exp'group#1'star#1 '[' {: goto_list :}
%resolve exp'group#1'star#1 String {: goto_list :}
%resolve exp'group#1'star#1 '{' {: goto_list :}
%resolve exp'group#1'star#1 '(' {: goto_list :}

%code {:
  local function suffix_dot(_, name)
    return {
      index = from(name),
      args = nil,
    }
  end
  local function suffix_bracket(_, exp)
    return {
      index = exp,
      args = nil,
    }
  end
  local function suffix_colon(_, name, args)
    return {
      index = from(name),
      args = args,
    }
  end
  local function suffix_args(args)
    return {
      index = nil,
      args = args,
    }
  end
:}

suffix := '.' Name {: suffix_dot :} | '[' $exp ']' {: suffix_bracket :} | ':' Name $args {: suffix_colon :} | $args {: suffix_args :}
primaryexp := Name [: from(_1) :] | '(' $exp ')' [: _2 :]

// %eps is func, the other 2 are assignments
// let's rule out the possibility of f() = x

assignment_or_call := $primaryexp (
                          '.' Name {: suffix_dot :}
                        | '[' $exp ']' {: suffix_bracket :}
                        | ':' Name $args {: suffix_colon :}
                        | <call> $args {: suffix_args :})* $assignment?
                      {:
                        function(left, suffixes, assignment_opt)
                          local assignment = #assignment_opt == 0 and {} or assignment_opt[1]
                          -- let's reduce to call or assignment
                          if (#suffixes == 0 or not suffixes[#suffixes].args) and #assignment == 0 then
                            error('Parser error: you can only specify a call or an assignment here')
                          end
                          if #suffixes ~= 0 and #assignment ~= 0 and suffixes[#suffixes].args then
                            error 'Parser error: you cannot assign to a call'
                          end
                          
                          if #assignment ~= 0 then
                            -- assignment case
                            -- assignment is a list of subsequent assignments
                            local ps = handle_primary_suffix(left, suffixes)
                            assert(ps.kind == 'index' or ps.kind == 'name')
                            local lvals, rvals = unpack(assignment)
                            table.insert(lvals, 1, ps)
                            local tree = node 'assignments'
                            tree.left = lvals
                            tree.right = rvals
                            return tree
                          else
                            -- call case
                            local ps = handle_primary_suffix(left, suffixes)
                            assert(ps.kind == 'call' or ps.kind == 'selfcall')
                            return ps
                          end
                        end
                      :}
assignment := ',' $primaryexp $suffix* $assignment 
              {: 
                function(_, _1, _2, _3) 
                  local left, right = unpack(_3)
                  left:list(handle_primary_suffix(_1, _2)); 
                  return {left, right}
                end :}
            | '=' $explist [: {node 'lvalue', _2} :]

    // Hack to get around the fact that one branch of this is always
    // "dead" states that would get killed later on anyways
    %resolve assignment_or_call'star#1 '(' {: function(self, tokens)
      -- always reduce to call
      return self:go '#list'
    end :}

    // prefixexp := $var | $functioncall | '(' $exp ')'
    // functioncall := $prefixexp ($args | ':' Name $args)
    // varlist := $var (',' $var)*
    // var := Name | $prefixexp ('[' $exp ']' | '.' Name)

args := '(' $explist? ')' [: (#_2 == 0 and node 'args') or node('args'):set('explist', _2[1]) :] 
      | $tableconstructor [: node('args'):list(_1) :]
      | String [: node('args'):list(from(_1)) :]

functiondef := 'function' $funcbody [: node('function'):set('parameters', _2[1]):set('body', _2[2]) :]

funcbody := '(' $parlist? ')' $block 'end'
          {: 
            function(_, parameters_opt, _, block)
              local parameters = parameters_opt[1] or node 'parameters'
              return {parameters, block}
            end 
          :}

    // resolve conflict for parlist := (Name ',')+ Name; based on tokens[2] being , or not
    %code {:
      local function parlist_namelist(namelist, trail)
        local parameters = node 'parameters'
        for name in utils.loop(parameters) do
          parameters:list(from(name))
        end
        if trail[1] == 'DOTS' then
          parameters.vararg = from(trail)
        else
          parameters:list(from(trail))
        end
        return parameters
      end
    :}

parlist := (<namelist> Name ',' [: _1 :])* (Name [: _1 :] | '...' [: _1 :]) 
            {: parlist_namelist :}

        %resolve parlist'star#1 Name {: function(self, tokens)
          if tostring(tokens[2]) == 'COMMA' then
            return self:go '#list'
          else
            return self:go ''
          end
        end :}

// TODO: ensure that only the last $field has an optional $fieldsep
tableconstructor := '{' $field* '}' 
    [: node('table'):list(unpack(_2)) :]

// Conflict resolvers, since the approximation of Lua we're parsing is not LL(1) (but is LL(2))
field := '[' $exp ']' '=' $exp $fieldsep? [: node('element'):set('index', _2):set('value', _5) :]
       | <assign> Name '=' $exp $fieldsep? [: node('element'):set('index', from(_1)):set('value', _3) :]
       | <exp> $exp $fieldsep? [: node('element'):set('value', _1) :]
%resolve field Name {: function(self, tokens)
  if tostring(tokens[2]) == 'EQ' then
    return self:go 'assign'
  else
    return self:go 'exp'
  end
end :}

fieldsep [: {} :] := ',' | ';'

binop [: from(_1, 'op') :] := '+' | '-' | '*' | '/' | '^' | '%' | '..' |
  '<' | '<=' | '>' | '>=' | '==' | '~=' | 
  'and' | 'or'

unop [: from(_1, 'op') :] := '-' | 'not' | '#'