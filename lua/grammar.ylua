%file "lua/parser"

// Conflict resolvers, since the approximation of Lua we're parsing is not LL(1) (but is LL(2))
%resolve field Name {: function(self, tokens)
  if tokens[2] == 'EQ' then
    return self:go 'assign'
  else
    return self:go 'exp'
  end
end :}

// resolve conflict for parlist := (Name ',')+ Name; based on tokens[2] being , or not
%resolve parlist'star#1 Name {: function(self, tokens)
  if tokens[2] == 'COMMA' then
    return self:go 'namelist'
  else
    return self:go ''
  end
end :}

%resolve stat'group#2 Name {: function(self, tokens)
  if tokens[2] == 'EQ' then
    return self:go 'forcounter'
  else
    return self:go 'foreach'
  end
end :}

// Hack to get around the fact that one branch of this is always
// "dead" states that would get killed later on anyways
%resolve assignment_or_call'star#1 '(' {: function(self, tokens)
  -- always reduce to call
  return self:go 'call'
end :}

%code {: local function goto_present(self) return self:go '#present' end :}
%resolve exp'maybe#1 '^' {: goto_present :}
%resolve exp'maybe#1 '==' {: goto_present :}
%resolve exp'maybe#1 '>=' {: goto_present :}
%resolve exp'maybe#1 '~=' {: goto_present :}
%resolve exp'maybe#1 '<=' {: goto_present :}
%resolve exp'maybe#1 '*' {: goto_present :}
%resolve exp'maybe#1 '>' {: goto_present :}
%resolve exp'maybe#1 '..' {: goto_present :}
%resolve exp'maybe#1 'and' {: goto_present :}
%resolve exp'maybe#1 'or' {: goto_present :}
%resolve exp'maybe#1 '/' {: goto_present :}
%resolve exp'maybe#1 '-' {: goto_present :}
%resolve exp'maybe#1 '+' {: goto_present :}
%resolve exp'maybe#1 '<' {: goto_present :}
%resolve exp'maybe#1 '%' {: goto_present :}

%code {: local function goto_list(self) return self:go '#list' end :}
%resolve exp'group#1'star#1 '[' {: goto_list :}
%resolve exp'group#1'star#1 String {: goto_list :}
%resolve exp'group#1'star#1 '{' {: goto_list :}
%resolve exp'group#1'star#1 '(' {: goto_list :}

%quote '(' LPAREN
%quote ',' COMMA
%quote ':' COLON
%quote '[' LBRACK
%quote ']' RBRACK
%quote '.' PERIOD
%quote '~=' NOTEQ
%quote '==' EQEQ
%quote '>=' GE
%quote '>' GT
%quote '<=' LE
%quote '<' LT
%quote '..' CONCAT
%quote '%' MOD
%quote '^' POW
%quote '/' DIV
%quote '*' MUL
%quote '-' MIN
%quote '+' PLUS
%quote '=' EQ
%quote '#' HASH
%quote ')' RPAREN
%quote ';' SEMICOLON
%quote '...' DOTS
%quote '{' LBRACE
%quote '}' RBRACE
%quote '::' QUAD
%quote 'function' FUNCTION
%quote 'true' TRUE
%quote 'false' FALSE
%quote 'nil' NIL
%quote 'or' OR
%quote 'and' AND
%quote 'return' RETURN
%quote 'local' LOCAL
%quote 'for' FOR
%quote 'in' IN
%quote 'do' DO
%quote 'end' END
%quote 'if' IF
%quote 'not' NOT
%quote 'then' THEN
%quote 'else' ELSE
%quote 'elseif' ELSEIF
%quote 'repeat' REPEAT
%quote 'until' UNTIL
%quote 'while' WHILE
%quote 'goto' GOTO
%quote 'break' BREAK

// Character classes of tokens
%production Name "class of valid identifiers"
%production String "class of valid strings"
%production Number "class of valid numbers"

%production FUNCTION
%production EQ
%production COMMA
%production QUAD
%production PERIOD
%production LPAREN
%production RPAREN
%production END
%production SEMICOLON
%production LBRACE
%production RBRACE
%production OR
%production AND
%production NOTEQ
%production EQEQ
%production GE
%production GT
%production LE
%production LT
%production CONCAT
%production MOD
%production POW
%production DIV
%production MUL
%production MIN
%production PLUS
%production LBRACK
%production RBRACK
%production LOCAL
%production FOR
%production IF
%production THEN
%production REPEAT
%production UNTIL
%production WHILE
%production DO
%production GOTO
%production BREAK
%production IN
%production RETURN
%production DOTS
%production TRUE
%production FALSE
%production NIL
%production ELSE
%production ELSEIF
%production HASH
%production NOT
%production COLON

// Let's create a set of trees where the children are recorded as integer indices
// and also as named fields
%code {:

local ast = {}
function ast:__newindex(key, val)
  assert(not self[key])
  rawset(self, key, val)
  table.insert(self, val)
  -- other stuff
  assert(not val.parent)
  rawset(val, 'parent', self)
end
setmetatable(ast, ast)

local function node(kind)
  return setmetatable({kind = kind}, ast)
end

local function from(token)
  local leaf = node 'leaf'
  leaf.value = token
  return leaf
end
:}

// A lua file is just a block
root := $block;

block := $stat* $retstat?;

stat := ';' | 
  $assignment_or_call |
  $label | 
  'break' | 
  'goto' Name | 
  'do' $block 'end' | 
  'while' $exp 'do' $block 'end' | 
  'repeat' $block 'until' $exp | 
  'if' $exp 'then' $block ('elseif' $exp 'then' $block;)* ('else' $block;)? 'end' | 
  'for' (
      <forcounter> Name '=' $exp ',' $exp (',' $exp;)? 'do' $block 'end' | 
      <foreach> $namelist 'in' $explist 'do' $block 'end';) | 
  'function' $funcname $funcbody | 
  'local' ('function' Name $funcbody | $namelist ('=' $explist;)?;);

retstat := 'return' $explist? ';'?;

label := '::' Name '::';

funcname := Name ('.' Name;)* (':' Name;)?;

namelist := Name (',' Name;)*;

explist := $exp (',' $exp;)*;

// there's a conflict on $binop between reducing the maybe? rule or going into the binop of the exp.
// luckily for us, since not binds are not as tight as the binary operators, we'd always be reducing the rule
exp := ('nil' | 'false' | 'true' | Number | String | '...' | $functiondef | 
  $primaryexp $suffix* | $tableconstructor | $unop $exp;) ($binop $exp;)?; // TODO: resolve conflict @ suffix*

suffix := '.' Name | '[' $exp ']' | ':' Name $args | $args;
primaryexp := Name | '(' $exp ')';

// %eps is func, the other 2 are assignments
// let's rule out the possibility of f() = x
assignment_or_call := $primaryexp ('.' Name | '[' $exp ']' | ':' Name $args | <call> $args;)* $assignment?;
assignment := ',' $primaryexp $suffix* $assignment | '=' $explist;

// prefixexp := $var | $functioncall | '(' $exp ')';

// functioncall := $prefixexp ($args | ':' Name $args;);

// varlist := $var (',' $var;)*;

// var := Name | $prefixexp ('[' $exp ']' | '.' Name;);

args := '(' $explist? ')' | $tableconstructor | String;

functiondef := 'function' $funcbody;

funcbody := '(' $parlist? ')' $block 'end';

parlist := (<namelist> Name ',';)+ (Name | '...';) | '...';

// TODO: ensure that only the last $field has an optional $fieldsep
tableconstructor := '{' $field* '}';

// TODO ADD ? BACK!
field := '[' $exp ']' '=' $exp $fieldsep? | <assign> Name '=' $exp $fieldsep? | <exp> $exp $fieldsep?;

fieldsep [: {} :] := ',' | ';';

binop [: from(_1) :] := '+' | '-' | '*' | '/' | '^' | '%' | '..' | 
  '<' | '<=' | '>' | '>=' | '==' | '~=' | 
  'and' | 'or';

unop [: from(_1) :] := '-' | 'not' | '#';