%require "common.utils"

%file "lua/parser"

%quote '(' LPAREN
%quote ',' COMMA
%quote ':' COLON
%quote '[' LBRACK
%quote ']' RBRACK
%quote '.' PERIOD
%quote '~=' NOTEQ
%quote '==' EQEQ
%quote '>=' GE
%quote '>' GT
%quote '<=' LE
%quote '<' LT
%quote '..' CONCAT
%quote '%' MOD
%quote '^' POW
%quote '/' DIV
%quote '*' MUL
%quote '-' MIN
%quote '+' PLUS
%quote '=' EQ
%quote '#' HASH
%quote ')' RPAREN
%quote ';' SEMICOLON
%quote '...' DOTS
%quote '{' LBRACE
%quote '}' RBRACE
%quote '::' QUAD
%quote 'function' FUNCTION
%quote 'true' TRUE
%quote 'false' FALSE
%quote 'nil' NIL
%quote 'or' OR
%quote 'and' AND
%quote 'return' RETURN
%quote 'local' LOCAL
%quote 'for' FOR
%quote 'in' IN
%quote 'do' DO
%quote 'end' END
%quote 'if' IF
%quote 'not' NOT
%quote 'then' THEN
%quote 'else' ELSE
%quote 'elseif' ELSEIF
%quote 'repeat' REPEAT
%quote 'until' UNTIL
%quote 'while' WHILE
%quote 'goto' GOTO
%quote 'break' BREAK

// Character classes of tokens
%production Name "class of valid identifiers"
%production String "class of valid strings"
%production Number "class of valid numbers"

%production FUNCTION
%production EQ
%production COMMA
%production QUAD
%production PERIOD
%production LPAREN
%production RPAREN
%production END
%production SEMICOLON
%production LBRACE
%production RBRACE
%production OR
%production AND
%production NOTEQ
%production EQEQ
%production GE
%production GT
%production LE
%production LT
%production CONCAT
%production MOD
%production POW
%production DIV
%production MUL
%production MIN
%production PLUS
%production LBRACK
%production RBRACK
%production LOCAL
%production FOR
%production IF
%production THEN
%production REPEAT
%production UNTIL
%production WHILE
%production DO
%production GOTO
%production BREAK
%production IN
%production RETURN
%production DOTS
%production TRUE
%production FALSE
%production NIL
%production ELSE
%production ELSEIF
%production HASH
%production NOT
%production COLON

// Let's create a set of trees where the children are recorded as integer indices
// and also as named fields
%code {:

local ast = {}
function ast:__newindex(key, val)
  if type(key) ~= 'string' then
    rawset(self, key, val)
  end
  assert(not self[key], 'Fields passed to a node should be initialized only once.')
  rawset(self, key, val)
  table.insert(self, val)
  -- other stuff
  if val.kind then
    assert(not val.parent, 'Fields passed to a node should be unowned.')
    rawset(val, 'parent', self)
  end
end

function ast:set(key, val)
  if not key or not val then return self end
  assert(val.kind, 'Set should only be called on child trees.')
  self[key] = val
  return self
end

function ast:list(...)
  list = {...}
  for child in utils.loop(list) do
    assert(child.kind, 'List should only be called on child trees.')
    table.insert(self, child)
    assert(not child.parent, 'Children passed to list(...) should be unowned.')
    rawset(child, 'parent', self)
  end
  return self
end

local function node(kind)
  return setmetatable({kind = kind}, {__index = ast, __newindex = ast.__newindex})
end

local function from(token)
  local leaf = node 'leaf'
  leaf.value = token
  return leaf
end
:}

// A lua file is just a block
root := $block [: _1 :]

block := $stat* $retstat? {: function(stats, ret)
  local tree = node 'block'
  tree:list(unpack(stats))
  
  return tree:set('ret', (#ret ~= 0 and ret[1]) or nil) 
end
:}

stat := ';' | 
  $assignment_or_call |
  $label | 
  'break' | 
  'goto' Name | 
  'do' $block 'end' | 
  'while' $exp 'do' $block 'end' | 
  'repeat' $block 'until' $exp | 
  'if' $exp 'then' $block ('elseif' $exp 'then' $block)* ('else' $block)? 'end' | 
  'for' (
      <forcounter> Name '=' $exp ',' $exp (',' $exp)? 'do' $block 'end' | 
      <foreach> $namelist 'in' $explist 'do' $block 'end') | 
  'function' $funcname $funcbody | 
  'local' ('function' Name $funcbody | $namelist ('=' $explist)?)

%resolve stat'group#2 Name {: function(self, tokens)
  if tokens[2] == 'EQ' then
    return self:go 'forcounter'
  else
    return self:go 'foreach'
  end
end :}

retstat := 'return' $explist? ';'?

label := '::' Name '::'

funcname := Name ('.' Name)* (':' Name)?

namelist := Name (',' Name)*

explist := $exp (',' $exp)*

// there's a conflict on $binop between reducing the maybe? rule or going into the binop of the exp.
// luckily for us, since not binds are not as tight as the binary operators, we'd always be reducing the rule
exp := ('nil' | 'false' | 'true' | Number | String | '...' | $functiondef | 
  $primaryexp $suffix* | $tableconstructor | $unop $exp) ($binop $exp)? // TODO: resolve conflict @ suffix*

%code {: local function goto_present(self) return self:go '#present' end :}
%resolve exp'maybe#1 '^' {: goto_present :}
%resolve exp'maybe#1 '==' {: goto_present :}
%resolve exp'maybe#1 '>=' {: goto_present :}
%resolve exp'maybe#1 '~=' {: goto_present :}
%resolve exp'maybe#1 '<=' {: goto_present :}
%resolve exp'maybe#1 '*' {: goto_present :}
%resolve exp'maybe#1 '>' {: goto_present :}
%resolve exp'maybe#1 '..' {: goto_present :}
%resolve exp'maybe#1 'and' {: goto_present :}
%resolve exp'maybe#1 'or' {: goto_present :}
%resolve exp'maybe#1 '/' {: goto_present :}
%resolve exp'maybe#1 '-' {: goto_present :}
%resolve exp'maybe#1 '+' {: goto_present :}
%resolve exp'maybe#1 '<' {: goto_present :}
%resolve exp'maybe#1 '%' {: goto_present :}

%code {: local function goto_list(self) return self:go '#list' end :}
%resolve exp'group#1'star#1 '[' {: goto_list :}
%resolve exp'group#1'star#1 String {: goto_list :}
%resolve exp'group#1'star#1 '{' {: goto_list :}
%resolve exp'group#1'star#1 '(' {: goto_list :}


suffix := '.' Name | '[' $exp ']' | ':' Name $args | $args
primaryexp := Name | '(' $exp ')'

// %eps is func, the other 2 are assignments
// let's rule out the possibility of f() = x
assignment_or_call := $primaryexp ('.' Name | '[' $exp ']' | ':' Name $args | <call> $args)* $assignment?
assignment := ',' $primaryexp $suffix* $assignment | '=' $explist

// Hack to get around the fact that one branch of this is always
// "dead" states that would get killed later on anyways
%resolve assignment_or_call'star#1 '(' {: function(self, tokens)
  -- always reduce to call
  return self:go 'call'
end :}

    // prefixexp := $var | $functioncall | '(' $exp ')'
    // functioncall := $prefixexp ($args | ':' Name $args)
    // varlist := $var (',' $var)*
    // var := Name | $prefixexp ('[' $exp ']' | '.' Name)

args := '(' $explist? ')' [: (#_2 == 0 and {}) or _2[1] :] 
      | $tableconstructor [: {_1} :]
      | String [: {from(_1)} :]

functiondef := 'function' $funcbody [: node('function'):set('parameters', _2[1]):set('body', _2[2]) :]

funcbody := '(' $parlist? ')' $block 'end'
          {: 
            function(_, parameters_opt, _, block)
              local parameters = (#parameters_opt == 0 and {}) or parameters_opt[1]
              return {parameters, block}
            end 
          :}

// resolve conflict for parlist := (Name ',')+ Name; based on tokens[2] being , or not
%code {:
  local function parlist_namelist(namelist, trail)
    local parameters = node 'parameters'
    for name in utils.loop(parameters) do
      parameters:list(from(name))
    end
    if trail[1] == 'DOTS' then
      parameters.vararg = from(trail)
    else
      parameters:list(from(trail))
    end
  end
:}

parlist := (<namelist> Name ',' [: _1 :])+ (Name [: _1 :] | '...' [: _1 :]) 
            {: parlist_namelist :}
         | '...' 
            [: node('parameters'):list(from(_1)) :]

        %resolve parlist'star#1 Name {: function(self, tokens)
          if tokens[2] == 'COMMA' then
            return self:go 'namelist'
          else
            return self:go ''
          end
        end :}

// TODO: ensure that only the last $field has an optional $fieldsep
tableconstructor := '{' $field* '}' 
    [: node('table'):list(unpack(_2)) :]

// Conflict resolvers, since the approximation of Lua we're parsing is not LL(1) (but is LL(2))
field := '[' $exp ']' '=' $exp $fieldsep? 
       | <assign> Name '=' $exp $fieldsep? 
       | <exp> $exp $fieldsep?
%resolve field Name {: function(self, tokens)
  if tokens[2] == 'EQ' then
    return self:go 'assign'
  else
    return self:go 'exp'
  end
end :}

fieldsep [: {} :] := ',' | ';'

binop [: from(_1) :] := '+' | '-' | '*' | '/' | '^' | '%' | '..' | 
  '<' | '<=' | '>' | '>=' | '==' | '~=' | 
  'and' | 'or'

unop [: from(_1) :] := '-' | 'not' | '#'